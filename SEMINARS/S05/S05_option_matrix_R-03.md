## 0) Контекст риска (из S04)

*   **Risk-ID:** `R-03`    **Threat:** `S (Spoofing), T (Tampering)`
*   **DFD element/edge:** Входящий поток `Webhook` от `External` → `Service`
*   **NFR link (ID):** `NFR-SEC-INT-001`
*   **L×I (1-5):** `L=3, I=4, Score=12`
*   **Ограничения/предпосылки:** Бизнес-процесс магазина полагается на получение статусов платежей в реальном времени через вебхуки от внешнего платежного провайдера.

## 1) Критерии и шкалы (1-5)

**Польза (чем больше - тем лучше, ↑):**

* **Security impact (↑):** насколько альтернатива снижает риск (предотвращает/обнаруживает/сдерживает).
* **Blast radius reduction (↑):** насколько сужает возможный ущерб (только один тенант/аккаунт/фича вместо всего сервиса).

**Стоимость/сложность (чем меньше - тем лучше, ↓):**

* **Complexity (↓):** сложность внедрения (код/конфиг/политики).
* **Time-to-mitigate (↓):** сколько времени до эффекта (в днях/спринтах).
* **Dependencies (↓):** внешние/внутренние зависимости (команды, провайдеры, миграции).

> Оценка **1-5**: 1 - минимально / 5 - максимально. Для «стоимостных» критериев **меньше - лучше**.

**Итоговые метрики (подсказка):**

* **Benefit = Security impact + Blast radius reduction**
* **Cost = Complexity + Time-to-mitigate + Dependencies**
* **Net = Benefit − Cost**  *(чем больше, тем привлекательнее)*

## 2) Таблица сравнения вариантов

| Alternative | Summary (1-2 фразы)                                                                           | Security impact (↑,1-5) | Blast radius reduction (↑,1-5) | Complexity (↓,1-5) | Time-to-mitigate (↓,1-5) | Dependencies (↓,1-5) | **Benefit** | **Cost** | **Net** | Notes                                                                                                     |
|:------------|:----------------------------------------------------------------------------------------------|:------------------------|:-------------------------------|:-------------------|:-------------------------|:---------------------|:------------|:---------|:--------|:----------------------------------------------------------------------------------------------------------|
| **A**       | **Проверка HMAC-подписи:** Валидация заголовка с подписью, сгенерированной на основе секрета. | 4                       | 4                              | 2                  | 1                        | 1                    | **8**       | **4**    | **+4**  | Стандарт индустрии. Надежно, быстро внедряется, большинство провайдеров предоставляют готовые библиотеки. |
| **B**       | **Фильтрация по IP-адресам:** Разрешить доступ к эндпоинту только с известных IP провайдера.  | 2                       | 3                              | 1                  | 1                        | 3                    | **5**       | **5**    | **0**   | Просто, но ненадежно. IP могут меняться, их можно подделать. Не защищает целостность сообщения.           |
| **C**       | **Опрос API (Polling):** Отказаться от вебхуков и вместо этого периодически опрашивать API.   | 5                       | 5                              | 5                  | 4                        | 3                    | **10**      | **12**   | **-2**  | Максимально безопасно, но архитектурно сложно: требуется фоновый воркер, управление состоянием.           |

## 3) Тай-брейкеры при равенстве Net

*   В данном случае `Net` однозначно указывает на преимущество варианта **A**.

## 4) Решение (для переноса в ADR)

*   **Chosen alternative:** **A**
*   **Почему:** Этот вариант является "золотым стандартом" для защиты вебхуков. Он обеспечивает криптографическую гарантию подлинности и целостности сообщения при очень низкой сложности реализации (Benefit=8, Cost=4). Вариант B (IP-фильтрация) слишком слаб для защиты от финансового мошенничества. Вариант C (Polling) хоть и надежен, но является избыточно сложным и дорогим решением для данной проблемы, а также вносит задержку в обработку платежей.
*   **ADR candidate (название):** `Webhook Signature Validation`
*   **Связки:** Risk-ID `R-03`, NFR-ID `NFR-SEC-INT-001`, DFD Поток `Webhook` от `External` к `Service`
*   **Следующие шаги (минимум):**
    1.  Получить секретный ключ для подписи вебхуков в личном кабинете платежного провайдера.
    2.  Реализовать middleware или декоратор для эндпоинта `/api/webhooks/payment-status`.
    3.  В middleware реализовать логику пересчета HMAC-SHA256 подписи на основе тела запроса и секрета.
    4.  Сравнить вычисленную подпись с подписью из заголовка (например, `X-Signature`).
    5.  В случае несовпадения — прерывать запрос с кодом `400 Bad Request` и логировать инцидент.