## 0) Контекст риска (из S04)

*   **Risk-ID:** `R-02`    **Threat:** `E (Elevation of Privilege), I (Information Disclosure), T (Tampering)`
*   **DFD element/edge:** Поток `API Gateway` → `Store Service` → `DB`
*   **NFR link (ID):** `NFR-SEC-AUTHZ-001`
*   **L×I (1-5):** `L=5, I=3, Score=15`
*   **Ограничения/предпосылки:** Система является многопользовательской, объекты (например, заказы) имеют четкого "владельца". Архитектура предполагает наличие единой точки входа для API-запросов.

## 1) Критерии и шкалы (1-5)

**Польза (чем больше - тем лучше, ↑):**

* **Security impact (↑):** насколько альтернатива снижает риск (предотвращает/обнаруживает/сдерживает).
* **Blast radius reduction (↑):** насколько сужает возможный ущерб (только один тенант/аккаунт/фича вместо всего сервиса).

**Стоимость/сложность (чем меньше - тем лучше, ↓):**

* **Complexity (↓):** сложность внедрения (код/конфиг/политики).
* **Time-to-mitigate (↓):** сколько времени до эффекта (в днях/спринтах).
* **Dependencies (↓):** внешние/внутренние зависимости (команды, провайдеры, миграции).

> Оценка **1-5**: 1 - минимально / 5 - максимально. Для «стоимостных» критериев **меньше - лучше**.

**Итоговые метрики (подсказка):**

* **Benefit = Security impact + Blast radius reduction**
* **Cost = Complexity + Time-to-mitigate + Dependencies**
* **Net = Benefit − Cost**  *(чем больше, тем привлекательнее)*

## 2) Таблица сравнения вариантов

| Alternative | Summary (1-2 фразы)                                                                               | Security impact (↑,1-5) | Blast radius reduction (↑,1-5) | Complexity (↓,1-5) | Time-to-mitigate (↓,1-5) | Dependencies (↓,1-5) | **Benefit** | **Cost** | **Net** | Notes                                                                                |
|:------------|:--------------------------------------------------------------------------------------------------|:------------------------|:-------------------------------|:-------------------|:-------------------------|:---------------------|:------------|:---------|:--------|:-------------------------------------------------------------------------------------|
| **A**       | **Централизованный AuthZ Middleware:** Единый компонент на уровне фреймворка проверяет права.     | 4                       | 4                              | 2                  | 2                        | 1                    | **8**       | **5**    | **+3**  | Надежно, предсказуемо и легко расширяемо. Стандарт индустрии для этой проблемы.      |
| **B**       | **Проверки "вручную" в каждом обработчике:** Разработчики сами пишут код проверки в каждой ручке. | 2                       | 2                              | 1                  | 1                        | 1                    | **4**       | **3**    | **+1**  | Очень подвержено человеческой ошибке. Легко забыть проверку в новом эндпоинте.       |
| **C**       | **Внешний Policy Engine (OPA/Casbin):** Авторизация делегируется внешнему сервису или библиотеке. | 5                       | 5                              | 5                  | 4                        | 4                    | **10**      | **13**   | **-3**  | Избыточно сложно для текущей задачи. Требует изучения нового стека (например, Rego). |

## 3) Тай-брейкеры при равенстве Net

*   В данном случае `Net` однозначно указывает на преимущество варианта **A**.

## 4) Решение (для переноса в ADR)

*   **Chosen alternative:** **A**
*   **Почему:** Этот вариант обеспечивает наилучший баланс. Он системно решает проблему IDOR (в отличие от ручных проверок, вариант B) и при этом не вводит избыточной сложности и внешних зависимостей (в отличие от варианта C). Централизованный подход гарантирует, что все новые эндпоинты будут защищены по умолчанию, что значительно снижает вероятность человеческой ошибки.
*   **ADR candidate (название):** `Centralized AuthZ Middleware`
*   **Связки:** Risk-ID `R-02`, NFR-ID `NFR-SEC-AUTHZ-001`, DFD `API Gateway -> Store Service`
*   **Следующие шаги (минимум):**
    1.  Реализовать middleware-компонент, который извлекает `userId` из JWT.
    2.  Middleware также извлекает `resourceId` из URL-параметра (например, `{orderId}`).
    3.  Middleware выполняет запрос к БД, чтобы проверить, что ресурс с `resourceId` принадлежит `userId`.
    4.  В случае несовпадения прав, middleware прерывает запрос и возвращает `404 Not Found`, чтобы не раскрывать факт существования ресурса.
    5.  Применить данный middleware ко всем эндпоинтам, работающим с ресурсами пользователя (например, `/api/orders/*`, `/api/profile/*`).